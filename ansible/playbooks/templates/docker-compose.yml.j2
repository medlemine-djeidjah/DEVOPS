version: '3.8'

services:
  frontend:
    image: "{{ frontend_image_name }}:{{ frontend_image_tag }}"
    container_name: frontend_app
    ports:
      - "80:80" # Exposes frontend on port 80 of vm2
    networks:
      - app_network
    restart: unless-stopped
    # If you were building from a local Dockerfile on vm2 (less common for this setup):
    # build:
    #   context: ./apps/frontend # Path relative to docker-compose.yml on vm2
    #   dockerfile: Dockerfile

  backend:
    image: "{{ backend_image_name }}:{{ backend_image_tag }}"
    container_name: backend_app
    ports:
      - "5000:5000" # Exposes backend on port 5000 of vm2
    environment:
      - DATABASE_URL=postgresql://db_user:db_password@database:5432/app_db
      # Add other environment variables as needed
    depends_on:
      - database
    networks:
      - app_network
    restart: unless-stopped
    # If building locally:
    # build:
    #   context: ./apps/backend
    #   dockerfile: Dockerfile

  database:
    image: "{{ database_image_name }}:{{ database_image_tag }}" # e.g., postgres:13-alpine
    container_name: database_service
    environment:
      POSTGRES_USER: "{{ db_user }}"
      POSTGRES_PASSWORD: "{{ db_password }}"
      POSTGRES_DB: "{{ db_name }}"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app_network
    ports:
      - "5432:5432" # Expose DB port only if needed externally from vm2, usually not for app internal comms
    restart: unless-stopped

networks:
  app_network:
    driver: bridge

volumes:
  postgres_data: # Persists database data 